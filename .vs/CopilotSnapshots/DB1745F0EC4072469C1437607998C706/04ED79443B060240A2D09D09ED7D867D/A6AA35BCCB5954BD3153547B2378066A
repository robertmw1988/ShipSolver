/**
 * Bulk Search & Output - Array-of-Objects Pattern
 */
function runBulkSearchesAndOutput() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sourceSheet = ss.getSheetByName(CFG.dataSheet); // Use AllArtifactData
  var resultsSheet = ss.getSheetByName(CFG.resultsSheet) || ss.insertSheet(CFG.resultsSheet);

  // 1. Get all data from the AllArtifactData sheet
  var allDataWithHeaders = sourceSheet.getDataRange().getValues();
  
  Logger.log('Using source sheet: %s (rows=%s, cols=%s)', 
             CFG.dataSheet, allDataWithHeaders.length, 
             (allDataWithHeaders[0] || []).length);
  
  if (!allDataWithHeaders || allDataWithHeaders.length < 5) {
    Logger.log("Source sheet is empty or has insufficient data.");
    return;
  }
  
  // AllArtifactData has 3 special header rows + 1 full header row
  var headers = allDataWithHeaders[3]; // Fourth row is the full header
  var masterDataRows = allDataWithHeaders.slice(4); // Data starts at row 5
  
  // Convert master data into array of objects
  var allRowsAsObjects = convertToObjects(headers, masterDataRows);
  Logger.log('Total source rows: %s', masterDataRows.length);
  
  // Log a sample row to see what we're working with
  if (allRowsAsObjects.length > 0) {
    var sampleRow = allRowsAsObjects[0];
    Logger.log('Sample row keys: %s', Object.keys(sampleRow).slice(0, 10).join(', '));
    Logger.log('Sample row ship type: "%s", duration: "%s", level: "%s"', 
               sampleRow['ship type'], 
               sampleRow['ship duration type'], 
               sampleRow['ship level']);
  }

  // 2. Build criteria sets from Ship_Parameters sheet
  var paramSheet = ss.getSheetByName(CFG.paramsSheet);
  var paramData = paramSheet.getDataRange().getValues();
  var paramHeaders = paramData[0];
  var shipTypeIdx = paramHeaders.indexOf(CFG.paramsCols.shipType);
  var shipDurationIdx = paramHeaders.indexOf(CFG.paramsCols.shipDurationType);
  var levelIdx = paramHeaders.indexOf(CFG.paramsCols.level);
  var criteriaSets = [];
  for (var i = 1; i < paramData.length; i++) {
    var row = paramData[i];
    // Only add criteria if at least one value is present
    if (row[shipTypeIdx] || row[shipDurationIdx] || 
        (row[levelIdx] !== undefined && row[levelIdx] !== '')) {
      var criteria = {};
      criteria[CFG.paramsCols.shipType] = row[shipTypeIdx];
      criteria[CFG.paramsCols.shipDurationType] = row[shipDurationIdx];
      criteria[CFG.paramsCols.level] = row[levelIdx];
      criteriaSets.push(criteria);
    }
  }

  // 3. Filter data for all criteria sets and collect results
  var combinedResults = [];
  var seenRows = {};
  Logger.log('Processing %s criteria sets', criteriaSets.length);
  criteriaSets.forEach(function(criteria) {
    Logger.log('Original criteria: %s', JSON.stringify(criteria));
    var matchingRows = filterDataByCriteria(allRowsAsObjects, criteria);
    Logger.log('Found %s matching rows for criteria', matchingRows.length);
    matchingRows.forEach(function(row) {
      var rowId = JSON.stringify(row);
      if (!seenRows[rowId]) {
        seenRows[rowId] = true;
        combinedResults.push(row);
      }
    });
  });
  Logger.log('Total unique rows after filtering: %s', combinedResults.length);

  // 4. Write the combined results to the results sheet
  if (combinedResults.length > 0) {
    // Get the special header rows from the source sheet
    var artifactTypes = allDataWithHeaders[0];
    var tiers = allDataWithHeaders[1];
    var rarities = allDataWithHeaders[2];
    var fullHeaders = allDataWithHeaders[3];
    
    // Convert results to 2D array
    var dataForSheet = convertObjectsTo2DArray(headers, combinedResults);
    
    // Prepare output with all header rows
    var outputRows = [
      artifactTypes,
      tiers,
      rarities,
      fullHeaders
    ].concat(dataForSheet);
    
    resultsSheet.clearContents();
    resultsSheet.getRange(1, 1, outputRows.length, outputRows[0].length).setValues(outputRows);
    Logger.log("Wrote %s unique rows to the Results sheet.", combinedResults.length);
  } else {
    resultsSheet.clearContents();
    resultsSheet.getRange(1,1,1,1).setValue('(no matches)');
    Logger.log("No matching rows found for any criteria.");
  }
}

function convertToObjects(headers, dataRows) {
  var dataAsObjectArray = [];
  for (var i = 0; i < dataRows.length; i++) {
    var row = dataRows[i];
    var entry = {};
    for (var j = 0; j < headers.length; j++) {
      if (headers[j] !== '') {
        entry[headers[j]] = row[j];
      }
    }
    dataAsObjectArray.push(entry);
  }
  return dataAsObjectArray;
}

function filterDataByCriteria(dataObjectArray, criteria) {
  // Skip empty criteria sets entirely
  if (!criteria['Ship type'] && !criteria['Ship duration type'] && 
      (criteria['Ship level'] === undefined || criteria['Ship level'] === '')) {
    return [];
  }

  // Map parameter sheet column names to data sheet column names
  // AllArtifactData uses capitalized column names
  var columnMap = {
    'Ship type': 'Ship type',
    'Ship duration type': 'Ship duration type',
    'Ship level': 'Ship level'
  };

  // Get aliases for normalization
  var aliases = _buildAliasesFromSheet();

  // Normalize the criteria values
  var normalizedCriteria = {};
  for (var key in criteria) {
    if (criteria.hasOwnProperty(key)) {
      var dataKey = columnMap[key] || key;
      var value = criteria[key];
      
      // Only include non-empty values
      if (value || value === 0) {
        // Normalize ship types and duration types
        if (key === 'Ship type') {
          value = _normalizeWithAliases('shipType', value, aliases);
        } else if (key === 'Ship duration type') {
          value = _normalizeWithAliases('shipDurationType', value, aliases);
        }
        
        normalizedCriteria[dataKey] = value;
      }
    }
  }

  Logger.log('Normalized criteria: %s', JSON.stringify(normalizedCriteria));

  return dataObjectArray.filter(function(row) {
    for (var key in normalizedCriteria) {
      // Never skip criteria - all normalized criteria must match

      // Normalize row values for comparison
      var rowValue = row[key];
      if (key === 'ship type') {
        rowValue = _normalizeWithAliases('shipType', rowValue, aliases);
      } else if (key === 'ship duration type') {
        rowValue = _normalizeWithAliases('shipDurationType', rowValue, aliases);
      }

      if (rowValue != normalizedCriteria[key]) {
        return false;
      }
    }
    return true;
  });
}

function convertObjectsTo2DArray(headers, objectArray) {
  var arr = [];
  for (var i = 0; i < objectArray.length; i++) {
    var obj = objectArray[i];
    var row = [];
    for (var j = 0; j < headers.length; j++) {
      row.push(obj[headers[j]]);
    }
    arr.push(row);
  }
  return arr;
}
/*******************************************************
 * Egg Inc. Virtue - Mission Retrieval & Solver Prep (ES5)
 * No const/let, no =>, no template literals, no ||= ?? ?.
 *******************************************************/

/* =========================
   CONFIGURATION
   ========================= */

var CFG = {
    // Sheet names
  dataSheet: 'AllArtifactData',          // Source data, used by _buildMissionIndex and _transformALLArtifactData
  sheetRawMissionDataTable: 'MissionDataRaw',
  sheetIndexedMissions: 'MissionDataIndexed',
  paramsSheet: 'Ship_Parameters',         // Parameters like ship levels

  aliasesSheet: 'Aliases',
  resultsSheet: 'ArtifactsByParams',

  dataCols: {
    shipType: 'ship type',
    shipDurationType: 'ship duration type',
    targetArtifact: 'target artifact',
    missionLevel: 'ship level'
  },

  // Map to the column names found on Ship_Parameters
  paramsCols: {
    shipType: 'Ship type',          // <- header in Ship_Parameters
    shipDurationType: 'Ship duration type',  // <- header in Ship_Parameters (Short/Standard/Extended/Tutorial)
    level: 'Ship level',       // <- user-configured star level per ship & type
    capacity: 'Capacity'       // <- mission capacity for calculating drop rates
  },

  aliasCols: { kind: 'kind', alias: 'alias', canonical: 'canonical' },
  defaultLevelIfMissing: 0,
  includeHeaderRow: true,
  includeUnknowns: true,
  cacheSeconds: 0
};

/* =========================
   CANONICAL KEY ORDER
   ========================= */


const Keys = Object.freeze({
  shipType: Object.freeze([
    'CHICKEN_ONE',
    'CHICKEN_NINE',
    'ATREGGIES',
    'CHICKEN_HEAVY',
    'BCR',
    'MILLENIUM_CHICKEN',
    'CORELLIHEN_CORVETTE',
    'GALEGGTICA',
    'CHICKFIANT',
    'VOYEGGER',
    'HENERPRISE',
  ]),

  shipDurationType: Object.freeze([
    'TUTORIAL',
    'SHORT',
    'LONG',
    'EPIC',
  ]),

  targetArtifact: Object.freeze([
    'UNKNOWN',
    'GOLD_METEORITE',
    'TAU_CETI_GEODE',
    'SOLAR_TITANIUM',
    'LUNAR_TOTEM',
    'DEMETERS_NECKLACE',
    'TUNGSTEN_ANKH',  
    'PUZZLE_CUBE',
    'INTERSTELLAR_COMPASS',
    'QUANTUM_METRONOME',
    'MERCURYS_LENS',
    'ORNATE_GUSSET',
    'THE_CHALICE',
    'BOOK_OF_BASAN',
    'PHOENIX_FEATHER',
    'VIAL_MARTIAN_DUST',
    'AURELIAN_BROOCH',
    'CARVED_RAINSTICK',
    'BEAK_OF_MIDAS',
    'SHIP_IN_A_BOTTLE',
    'TACHYON_DEFLECTOR',
    'DILITHIUM_MONOCLE',
    'TITANIUM_ACTUATOR',
    'NEODYMIUM_MEDALLION',
    'LIGHT_OF_EGGENDIL',
    'LUNAR_STONE_FRAGMENT',
    'LUNAR_STONE',
    'QUANTUM_STONE_FRAGMENT',
    'QUANTUM_STONE',
    'TACHYON_STONE_FRAGMENT',
    'TACHYON_STONE',
    'SOUL_STONE_FRAGMENT',
    'SOUL_STONE',
    'DILITHIUM_STONE_FRAGMENT',
    'DILITHIUM_STONE',
    'SHELL_STONE_FRAGMENT',
    'SHELL_STONE',
    'TERRA_STONE_FRAGMENT',
    'TERRA_STONE',
    'LIFE_STONE_FRAGMENT',
    'LIFE_STONE',
    'PROPHECY_STONE_FRAGMENT',
    'PROPHECY_STONE',
    'CLARITY_STONE_FRAGMENT',
    'CLARITY_STONE',
  ]),
});



/* =========================
   UTILITIES
   ========================= */
function _toUpperSnake(s) {
  if (s == null) return '';
  return String(s).trim().replace(/[\s\-]+/g, '_').toUpperCase();
}

function _getsheetbyname(sheetName) {
  return SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
}

function _transformALLArtifactData() {
  // Read the pre-transformed data (now has 3 header rows + 1 full header row)
  var sheet = _getsheetbyname(CFG.dataSheet);
  var data = sheet.getDataRange().getValues();
  
  // Extract headers and data structure
  // First row: artifact types (artifact columns start at index 4).
  // Prepend 4 empty cells so these header rows line up with the full header row (which includes the first 4 key columns).
  var prefixEmpty = ["", "", "", ""]; // for ship type, duration, level, target
  var artifactTypes = prefixEmpty.concat(data[0].slice(4));  // First row: artifact types
  var tiers = prefixEmpty.concat(data[1].slice(4));          // Second row: tiers
  var rarities = prefixEmpty.concat(data[2].slice(4));       // Third row: rarities
  var fullHeaders = data[3];             // Fourth row: complete headers (already includes key columns)
  var rows = data.slice(4);              // Actual data starts at row 5

  // Ensure the short header rows are padded to match the full header length
  try {
    var targetLen = (fullHeaders && fullHeaders.length) || artifactTypes.length;
    while (artifactTypes.length < targetLen) artifactTypes.push('');
    while (tiers.length < targetLen) tiers.push('');
    while (rarities.length < targetLen) rarities.push('');
    
    // Log the actual lengths after padding
    Logger.log("After padding - artifactTypes: " + artifactTypes.length + 
               ", tiers: " + tiers.length + 
               ", rarities: " + rarities.length + 
               ", fullHeaders: " + fullHeaders.length);
  } catch (e) {
    Logger.log("Error during padding: " + e);
  }

  // Load ship filters from 'Ship_Parameters' sheet
  var paramSheet = _getsheetbyname(CFG.paramsSheet);
  var paramData = paramSheet.getDataRange().getValues();
  var paramHeaders = paramData[0];
  var shipTypeIndex = paramHeaders.indexOf(CFG.paramsCols.shipType);
  var shipLevelIndex = paramHeaders.indexOf(CFG.paramsCols.level);
  var shipFilters = [];
  for (var i = 1; i < paramData.length; i++) {
    shipFilters.push([paramData[i][shipTypeIndex], paramData[i][shipLevelIndex]]);
  }

  // Filter rows based on shipFilters
  var filteredRows = [];
  for (var r = 0; r < rows.length; r++) {
    var row = rows[r];
    for (var f = 0; f < shipFilters.length; f++) {
      if (row[0] === shipFilters[f][0] &&    // Ship type is first column
          row[2] === shipFilters[f][1]) {     // Ship level is third column
        filteredRows.push(row);
        break;
      }
    }
  }

  // Prepare output with the same structure as input
  var outputRows = [
    artifactTypes,    // Row 1: Artifact types
    tiers,           // Row 2: Tiers
    rarities,        // Row 3: Rarities
    fullHeaders      // Row 4: Complete headers
  ];

  // Add filtered rows to output
  outputRows = outputRows.concat(filteredRows);

  // Write to output sheet
  var outputSheet = _getsheetbyname(CFG.sheetRawMissionDataTable);
  if (!outputSheet) {
    outputSheet = SpreadsheetApp.getActive().insertSheet(CFG.sheetRawMissionDataTable);
  }
  
  // Clear the sheet and resize it to match the output data
  outputSheet.clear();
  
  if (outputRows.length <= 4) { // Only headers, no data
    outputSheet.getRange(1, 1, 1, 1).setValue('(no matches)');
    return;
  }
  
  // Ensure sheet has enough columns
  var currentCols = outputSheet.getMaxColumns();
  var neededCols = outputRows[0].length;
  // Ensure the sheet has at least neededCols columns. Insert in a loop to avoid API limits.
  while (outputSheet.getMaxColumns() < neededCols) {
    var add = Math.min(50, neededCols - outputSheet.getMaxColumns());
    outputSheet.insertColumnsAfter(outputSheet.getMaxColumns(), add);
  }

  // Ensure enough rows as well
  while (outputSheet.getMaxRows() < outputRows.length) {
    var addRows = Math.min(1000, outputRows.length - outputSheet.getMaxRows());
    outputSheet.insertRowsAfter(outputSheet.getMaxRows(), addRows);
  }

  // Force pending changes to apply before write
  SpreadsheetApp.flush();

  // Write all rows including headers; explicitly use neededCols to avoid mismatch
  outputSheet.getRange(1, 1, outputRows.length, neededCols).setValues(outputRows);

  // Delete the pivot section as it's not properly defined
  // We'll handle the data transformation in GET_MISSION_ROWS_BY_PARAM instead
  return;
}


// Reads a sheet and returns { header: { colNameLower: index }, rows: [...], all: [...] }
function _readSheet(sheetName) {
  var sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) throw new Error('Sheet not found: ' + sheetName);
  var lr = sh.getLastRow();
  var lc = sh.getLastColumn();
  if (lr < 1 || lc < 1) return { header: {}, rows: [], all: [] };
  var all = sh.getRange(1, 1, lr, lc).getValues();
  if (!all.length) return { header: {}, rows: [], all: [] };
  var hdrArr = all[0];
  var header = {};
  for (var i = 0; i < hdrArr.length; i++) {
    var h = String(hdrArr[i] == null ? '' : hdrArr[i]).trim();
    header[h.toLowerCase()] = i;
  }
  return { header: header, rows: all.slice(1), all: all };
}

// Cache helpers (document cache)
function _cacheGet(key) {
  try {
    var cache = CacheService.getDocumentCache();
    var v = cache.get(key);
    return v ? JSON.parse(v) : null;
  } catch (e) {
    return null;
  }
}
function _cachePut(key, obj, seconds) {
  try {
    var cache = CacheService.getDocumentCache();
    cache.put(key, JSON.stringify(obj), seconds);
  } catch (e) {}
}

/* =========================
   ALIASES BUILDING
   ========================= */
function _buildAliasesFromSheet() {
  var ck = 'aliases:' + CFG.aliasesSheet;
  var cached = _cacheGet(ck);
  if (cached) return cached;

  var map = { shipType: {}, shipDurationType: {}, targetArtifact: {} };
  var sh = SpreadsheetApp.getActive().getSheetByName(CFG.aliasesSheet);
  if (!sh) { _cachePut(ck, map, CFG.cacheSeconds); return map; }

  var read = _readSheet(CFG.aliasesSheet);
  var header = read.header, rows = read.rows;
  var cK = header[CFG.aliasCols.kind.toLowerCase()];
  var cA = header[CFG.aliasCols.alias.toLowerCase()];
  var cC = header[CFG.aliasCols.canonical.toLowerCase()];

  if (cK == null || cA == null || cC == null) {
    _cachePut(ck, map, CFG.cacheSeconds);
    return map;
  }

  for (var i = 0; i < rows.length; i++) {
    var r = rows[i];
    var kind  = String((r[cK] || '')).trim();
    var alias = String((r[cA] || '')).trim();
    var canon = String((r[cC] || '')).trim();
    if (!kind || !alias || !canon) continue;

    if (!map[kind]) map[kind] = {};
    map[kind][alias] = canon;
    map[kind][_toUpperSnake(alias)] = canon; // convenience
  }

  _cachePut(ck, map, CFG.cacheSeconds);
  return map;
}

//TODO: check if this works with current _transformALLArtifactData usage
function _normalizeWithAliases(kind, value, aliases) {
  var raw = String(value == null ? '' : value).trim();
  if (!raw) return '';

  // 1) Exact alias match
  if (aliases && aliases[kind] && aliases[kind][raw]) return aliases[kind][raw];

  // 2) Upper_snake variant alias match
  var up = _toUpperSnake(raw);
  if (aliases && aliases[kind] && aliases[kind][up]) return aliases[kind][up];

  // 3) Heuristic fallback for ships (handle common “display” names)
  if (kind === 'shipType') {
    // Map well-known variants/prefixes to canonical keys
    // Feel free to add lines here if you discover new patterns.
    if (/^ATREGGIES(?:[_\s-]?HENLINER)?$/i.test(raw)) return 'ATREGGIES';
    if (/^CORNISH[\s-]?HEN[\s-]?CORVETTE$/i.test(raw)) return 'CORELLIHEN_CORVETTE';
    if (/^DEFIHENT$/i.test(raw)) return 'CHICKFIANT';      // typo -> canonical
    if (/^VOYEGGER$/i.test(raw)) return 'VOYEGGER';
    if (/^HENERPRISE$/i.test(raw)) return 'HENERPRISE';
    if (/^CHICKEN[\s-]?ONE$/i.test(raw)) return 'CHICKEN_ONE';
    if (/^CHICKEN[\s-]?NINE$/i.test(raw)) return 'CHICKEN_NINE';
    if (/^CHICKEN[\s-]?HEAVY$/i.test(raw)) return 'CHICKEN_HEAVY';
    if (/^BCR$/i.test(raw)) return 'BCR';
    if (/^MILLEN(IA|IU)M[\s-]?CHICKEN$/i.test(raw)) return 'MILLENIUM_CHICKEN';
    if (/^GALEGG(T|TT)ICA$/i.test(raw)) return 'GALEGGTICA';
  }

  // 4) Heuristic fallback for durations (readable -> canonical)
  if (kind === 'shipDurationType') {
    if (/^SHORT$/i.test(raw)) return 'SHORT';
    if (/^STANDARD$/i.test(raw)) return 'STANDARD';
    if (/^EXTENDED$/i.test(raw)) return 'EXTENDED';
    if (/^TUTORIAL$/i.test(raw)) return 'TUTORIAL';
  }

  // 5) Default: upper_snake
  return up;
}


/* =========================
   FLEXIBLE COLUMN RESOLUTION
   ========================= */
var SYNONYMS = {
  shipType:        ['Ship type', 'Shiptype', 'ship','ship_name'],
  shipDurationType:['Ship duration type','durationtype','type','missiontype','duration'],
  targetArtifact:  ['Target artifact','target'],
  missionLevel:    ['Mission level','level','lvl']
};

function _resolveCols(header, desired) {
  var out = {};
  for (var logical in desired) {
    if (!desired.hasOwnProperty(logical)) continue;
    var prefer = String(desired[logical] || '').toLowerCase();
    var idx = header[prefer];
    if (idx == null) {
      var alts = SYNONYMS[logical] || [];
      for (var i = 0; i < alts.length; i++) {
        var alt = alts[i];
        var altKey = String(alt).toLowerCase();
        if header.hasOwnProperty(altKey)) { idx = header[altKey]; break; }
      }
    }
    if (idx == null) {
      throw new Error("Column '" + desired[logical] + "' for " + logical + " not found and no synonyms matched.");
    }
    out[logical] = idx;
  }
  return out;
}

/* =========================
   PARAM MAP: (stype␞sdur) -> level (object dict)
   ========================= */

//TODO: check if this works with current _transformALLArtifactData usage
function _buildParamLevelMap() {
  var ck = 'paramMap:' + CFG.paramsSheet;
  var cached = _cacheGet(ck);
  if (cached) {
    var obj = {};
    for (var i = 0; i < cached.length; i++) {
      obj[cached[i][0]] = { level: cached[i][1], capacity: cached[i][2] };
    }
    return obj;
  }

  var read = _readSheet(CFG.paramsSheet);
  var header = read.header, rows = read.rows;

  var cSt = header[String(CFG.paramsCols.shipType).toLowerCase()];
  var cDu = header[String(CFG.paramsCols.shipDurationType).toLowerCase()];
  var cLv = header[String(CFG.paramsCols.level).toLowerCase()];
  var cCap = header[String(CFG.paramsCols.capacity).toLowerCase()];
  if (cSt == null || cDu == null || cLv == null || cCap == null) {
    throw new Error(
      "Params '" + CFG.paramsSheet + "' must have headers: " +
      CFG.paramsCols.shipType + ", " + CFG.paramsCols.shipDurationType + ", " + 
      CFG.paramsCols.level + ", " + CFG.paramsCols.capacity
    );
  }

  var aliases = _buildAliasesFromSheet();
  var map = {};
  var serial = [];

  for (var r = 0; r < rows.length; r++) {
    var row = rows[r];
    // normalize Ship / Type with your existing Aliases
    var st = _normalizeWithAliases('shipType',        row[cSt], aliases);
    var du = _normalizeWithAliases('shipDurationType', row[cDu], aliases);
    var lv = row[cLv]; // <-- USE StarsHelper AS-IS (e.g., 0..8)
    var cap = row[cCap]; // <-- Mission capacity
    if (!st || !du) continue;

    var key = st + '␞' + du;
    map[key] = { level: lv, capacity: cap };
    serial.push([key, lv, cap]);
  }

  _cachePut(ck, serial, CFG.cacheSeconds);
  return map;
}



/* =========================
   BUILD DATA INDEX (AllArtifactData)
   stype -> sdur -> level -> artifact -> [rowIndex]
   ========================= */

   //TODO: check if this works with current _transformALLArtifactData usage
function _buildMissionIndex() {
  var ck = 'index:' + CFG.dataSheet;
  var cached = _cacheGet(ck);
  if (cached) {
    Logger.log('Using cached mission index');
    return cached;
  }
  Logger.log('Building new mission index');

  var read = _readSheet(CFG.dataSheet);
  var header = read.header, rows = read.rows, all = read.all;

  var cols = _resolveCols(header, CFG.dataCols);
  var aliases = _buildAliasesFromSheet();

  var index = {};
  for (var i = 0; i < rows.length; i++) {
    var r = rows[i];
    var st = _normalizeWithAliases('shipType',        r[cols.shipType], aliases);
    var du = _normalizeWithAliases('shipDurationType', r[cols.shipDurationType], aliases);
    var ta = _normalizeWithAliases('targetArtifact',   r[cols.targetArtifact], aliases);
    var lv = r[cols.missionLevel];

    if (!st || !du || ta == null || lv == null || lv === '') {
      if (i < 5) Logger.log('Skipped row %s: st=%s, du=%s, ta=%s, lv=%s', 
                           i + 2, st, du, ta, lv);
      continue;
    }

    var lvKey = String(lv);
    if (!index[st]) {
      index[st] = {};
      Logger.log('Created new ship type index for %s', st);
    }
    if (!index[st][du]) {
      index[st][du] = {};
      Logger.log('Created new duration index for %s - %s', st, du);
    }
    if (!index[st][du][lvKey]) {
      index[st][du][lvKey] = {};
      Logger.log('Created new level index for %s - %s - %s', st, du, lvKey);
    }
    if (!index[st][du][lvKey][ta]) {
      index[st][du][lvKey][ta] = [];
      Logger.log('Created new target artifact array for %s - %s - %s - %s', st, du, lvKey, ta);
    }
    index[st][du][lvKey][ta].push(i + 2); // store 1-based row index (header offset)
  }

  var packed = { index: index, header: header, all: all, cols: cols };
  // Defensive cleanup: remove any accidental header-like keys from the index
  try {
    var badKey = _toUpperSnake(CFG.paramsCols.shipType);
    if (packed.index && packed.index.hasOwnProperty(badKey)) delete packed.index[badKey];
    if (packed.index && packed.index.hasOwnProperty('SHIP_TYPE')) delete packed.index['SHIP_TYPE'];
  } catch (e) {}
  Logger.log('Mission index built - rows indexed: %s, ship types: %s', rows.length, Object.keys(index).join(', '));
  _cachePut(ck, packed, CFG.cacheSeconds);
  return packed;
}

/* =========================
   CANONICAL ORDER HELPERS
   ========================= */

function _orderValueKeysByArtifact(valueKeys) {
  // Create map of artifact name to canonical index
  var canonicalIndex = {};
  for (var i = 0; i < Keys.targetArtifact.length; i++) {
    canonicalIndex[Keys.targetArtifact[i]] = i;
  }

  // Sort by extracting artifact name from "ARTIFACT | TIER | RARITY" format
  // and using canonical index or fallback to alphabetical
  return valueKeys.sort(function(a, b) {
    var aArtifact = a.split(" | ")[0];
    var bArtifact = b.split(" | ")[0];
    var aIdx = canonicalIndex[aArtifact];
    var bIdx = canonicalIndex[bArtifact];
    
    // If both have canonical positions, use those
    if (aIdx !== undefined && bIdx !== undefined) {
      return aIdx - bIdx;
    }
    // If only one has position, it goes first
    if (aIdx !== undefined) return -1;
    if (bIdx !== undefined) return 1;
    // Otherwise alphabetical
    return a.localeCompare(b);
  });
}
function _appendUnknowns(canonicalList, actualKeys) {
  var actualSet = {};
  for (var i = 0; i < actualKeys.length; i++) actualSet[actualKeys[i]] = true;

  var seen = {};
  var out = [];
  // canonical first
  for (var c = 0; c < canonicalList.length; c++) {
    var k = canonicalList[c];
    if (actualSet[k]) { out.push(k); seen[k] = true; }
  }
  // then unknowns in actual order
  for (var j = 0; j < actualKeys.length; j++) {
    var a = actualKeys[j];
    if (!seen[a]) out.push(a);
  }
  return out;
}

/* =========================
   SPILL FUNCTION (no level sort)
   ========================= */
/**
 * Returns full rows from AllArtifactData where:
 *   missionLevel == Params level for that (shipType, shipDurationType).
 * Output order: shipType -> shipDurationType -> targetArtifact (canonical).
 * Usage: =GET_MISSION_ROWS_BY_PARAM()
 */

 //TODO: check if this works with current _transformALLArtifactData usage
function GET_MISSION_ROWS_BY_PARAM() {
  var built = _buildMissionIndex();
  var index = built.index, all = built.all;
  var paramMap = _buildParamLevelMap();
  
  Logger.log('Mission Index built - all rows: %s', all.length);
  Logger.log('ParamMap keys: %s', Object.keys(paramMap).join(', '));
  Logger.log('ShipTypes in index: %s', Object.keys(index).join(', '));

  var out = [];
  if (CFG.includeHeaderRow) out.push(all[0]);

  var stActual = Object.keys(index);
  var stKeys;
  if (CFG.includeUnknowns) stKeys = _appendUnknowns(Keys.shipType, stActual);
  else {
    stKeys = [];
    for (var si = 0; si < Keys.shipType.length; si++) {
      var sk = Keys.shipType[si];
      if (stActual.indexOf(sk) !== -1) stKeys.push(sk);
    }
  }

  for (var s = 0; s < stKeys.length; s++) {
    var st = stKeys[s];
    var duMap = index[st];
    Logger.log('For ship %s: found durations = %s', 
               st, duMap ? Object.keys(duMap).join(', ') : 'none');
    if (!duMap) continue;

    var duActual = Object.keys(duMap);
    var duKeys;
    if (CFG.includeUnknowns) duKeys = _appendUnknowns(Keys.shipDurationType, duActual);
    else {
      duKeys = [];
      for (var di = 0; di < Keys.shipDurationType.length; di++) {
        var dk = Keys.shipDurationType[di];
        if (duActual.indexOf(dk) !== -1) duKeys.push(dk);
      }
    }

    for (var d = 0; d < duKeys.length; d++) {
      var du = duKeys[d];

      var pLvRaw = paramMap[st + '␞' + du];
      Logger.log('Processing %s - %s: param level raw = %s', st, du, pLvRaw);
      var pLv = (pLvRaw == null || pLvRaw === '') ? CFG.defaultLevelIfMissing : pLvRaw;

      var lvMap = duMap[String(pLv)];
      Logger.log('For %s - %s - level %s: found map = %s', 
                st, du, pLv, lvMap ? 'yes (keys: ' + Object.keys(lvMap).join(', ') + ')' : 'no');
      if (!lvMap) continue;

      var taActual = Object.keys(lvMap);
      var taKeys;
      if (CFG.includeUnknowns) taKeys = _appendUnknowns(Keys.targetArtifact, taActual);
      else {
        taKeys = [];
        for (var ti = 0; ti < Keys.targetArtifact.length; ti++) {
          var tg = Keys.targetArtifact[ti];
          if (taActual.indexOf(tg) !== -1) taKeys.push(tg);
        }
      }

      for (var t = 0; t < taKeys.length; t++) {
        var ta = taKeys[t];
        var rowIdxs = lvMap[ta];
        Logger.log('Checking %s - %s - level %s - target %s: found %s rows', 
                  st, du, pLv, ta, (rowIdxs && rowIdxs.length) || 0);
        if (!rowIdxs || !rowIdxs.length) continue;
        for (var r = 0; r < rowIdxs.length; r++) {
          var ri = rowIdxs[r];
          out.push(all[ri - 1]);
        }
      }
    }
  }

  if (out.length === (CFG.includeHeaderRow ? 1 : 0)) return [['(no matches)']];
  return out;
}

/**
 * Optional projection:
 *   =GET_MISSION_ROWS_BY_PARAM_PROJECTED(4)
 *   =GET_MISSION_ROWS_BY_PARAM_PROJECTED("shipType","shipDurationType","missionLevel","targetArtifact")
 */

 //TODO: check if this works with current _transformALLArtifactData usage
function GET_MISSION_ROWS_BY_PARAM_PROJECTED() {
  var args = Array.prototype.slice.call(arguments);
  var rows = GET_MISSION_ROWS_BY_PARAM();
  if (!rows || !rows.length) return rows;

  if (args.length === 1 && typeof args[0] === 'number') {
    var n = Math.max(1, args[0]);
    var projA = [];
    for (var i = 0; i < rows.length; i++) projA.push(rows[i].slice(0, n));
    return projA;
  }

  if (args.length > 0 && typeof args[0] === 'string') {
    var header = rows[0];
    var map = {};
    for (var h = 0; h < header.length; h++) map[String(header[h]).toLowerCase()] = h;

    var idxs = [];
    for (var a = 0; a < args.length; a++) {
      var name = String(args[a]).toLowerCase();
      if (map[name] == null) throw new Error('Column not found in output: ' + args[a]);
      idxs.push(map[name]);
    }
    var proj = [];
    for (var r = 0; r < rows.length; r++) {
      var row = rows[r], outRow = [];
      for (var k = 0; k < idxs.length; k++) outRow.push(row[idxs[k]]);
      proj.push(outRow);
    }
    return proj;
  }

  return rows;
}

/* =========================
   WRITERS FOR SOLVER
   ========================= */

function WRITE_RESULTS_SHEET() {
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(CFG.resultsSheet) || ss.insertSheet(CFG.resultsSheet);
  var data = GET_MISSION_ROWS_BY_PARAM();
  sh.clearContents();
  if (!data || !data.length) {
    sh.getRange(1,1,1,1).setValue('(no matches)');
    return;
  }
  sh.getRange(1,1,data.length,data[0].length).setValues(data);
}

function WRITE_RESULTS_KEYS_ONLY() {
  var full = GET_MISSION_ROWS_BY_PARAM();
  if (!full || !full.length) return;

  var header = full[0];
  var map = {};
  for (var i = 0; i < header.length; i++) map[String(header[i]).toLowerCase()] = i;

  // Use consistent column names from CFG
  var colsToExtract = [
    'ship type',
    'ship duration type',
    'ship level',
    'target artifact'
  ];
  
  // Verify all required columns exist
  for (var n = 0; n < colsToExtract.length; n++) {
    if (map[colsToExtract[n]] == null) {
      throw new Error('Missing column in results: ' + colsToExtract[n]);
    }
  }

  var slim = [['shipType','shipDurationType','level','targetArtifact']];
  for (var r = 1; r < full.length; r++) {
    var row = full[r];
    slim.push([
      row[map[colsToExtract[0]]],
      row[map[colsToExtract[1]]],
      row[map[colsToExtract[2]]],
      row[map[colsToExtract[3]]]
    ]);
  }

  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(CFG.resultsSheet) || ss.insertSheet(CFG.resultsSheet);
  sh.clearContents();
  sh.getRange(1,1,slim.length,slim[0].length).setValues(slim);
}



function CLEAR_CACHE() {
  var c = CacheService.getDocumentCache();
  c.remove('index:' + CFG.dataSheet);
  c.remove('paramMap:' + CFG.paramsSheet);
  c.remove('aliases:' + CFG.aliasesSheet);
}


 /**
 * Show what star levels exist in the data for a given ship + duration pair.
 * This helps diagnose missing data versus configuration mismatches.
 */
function DIAG_LEVELS_FOR_PAIR(ship, duration) {
  var built = _buildMissionIndex();
  var aliases = _buildAliasesFromSheet();
  var st = _normalizeWithAliases('shipType', ship, aliases);
  du = _normalizeWithAliases('shipDurationType', duration, aliases);
  
  Logger.log('Checking levels in %s for:', CFG.dataSheet);
  Logger.log('  Ship: %s (from "%s")', st, ship);
  Logger.log('  Duration: %s (from "%s")', du, duration);
  
  var duMap = built.index[st];
  if (!duMap) {
    Logger.log('No data found for ship: %s', st);
    Logger.log('Available ships: %s', JSON.stringify(Object.keys(built.index).sort()));
    return;
  }
  
  duMap = duMap[du];
  if (!duMap) {
    Logger.log('No data found for duration: %s', du);
    Logger.log('Available durations for %s: %s', st, JSON.stringify(Object.keys(built.index[st]).sort()));
    return;
  }
  
  var levels = Object.keys(duMap).sort(function(a,b){return Number(a)-Number(b);});
  Logger.log('Found star levels: %s', JSON.stringify(levels));
}

/**
 * Test level lookup with a common ship configuration.
 */
function DIAG_TEST_LEVELS_FOR_PAIR() {
  DIAG_LEVELS_FOR_PAIR('Atreggies Henliner','Short');
  DIAG_PARAM_FOR_PAIR('Atreggies Henliner', 'Short');
}

/**
 * Show what level is configured in parameters for a ship + duration pair.
 */
function DIAG_PARAM_FOR_PAIR(ship, duration) {
  var params = _buildParamLevelMap();
  var aliases = _buildAliasesFromSheet();
  var st = _normalizeWithAliases('shipType', ship, aliases);
  var du = _normalizeWithAliases('shipDurationType', duration, aliases);
  var key = st + '␞' + du;
  
  Logger.log('Checking configuration in %s for:', CFG.paramsSheet);
  Logger.log('  Ship: %s (from "%s")', st, ship);
  Logger.log('  Duration: %s (from "%s")', du, duration);
  Logger.log('  Configured level: %s', params[key]);
}

/**
 * Display headers from the data sheet to help diagnose column name issues.
 */
function DIAG_HEADERS() {
  var read = _readSheet(CFG.dataSheet);
  Logger.log('Data sheet: %s', CFG.dataSheet);
  Logger.log('Headers: %s', JSON.stringify(read.header));
  
  // Also show parameter sheet headers
  var paramRead = _readSheet(CFG.paramsSheet);
  Logger.log('Param sheet: %s', CFG.paramsSheet);
  Logger.log('Param headers: %s', JSON.stringify(paramRead.header));
}

/**
 * Diagnostic: show transform intermediate sizes without writing.
 */
function DIAG_TRANSFORM_STATS() {
  var sheet = _getsheetbyname(CFG.dataSheet);
  if (!sheet) { Logger.log('Data sheet not found: %s', CFG.dataSheet); return; }
  var data = sheet.getDataRange().getValues();
  if (!data || !data.length) { Logger.log('No data in %s', CFG.dataSheet); return; }

  // Add the 4 prefix cells like in _transformALLArtifactData
  var prefixEmpty = ["", "", "", ""];
  var artifactTypes = prefixEmpty.concat(data[0].slice(4));
  var tiers = prefixEmpty.concat(data[1].slice(4));
  var rarities = prefixEmpty.concat(data[2].slice(4));
  var fullHeaders = data[3] || [];
  var rows = data.slice(4);

  // Ensure padding like in _transformALLArtifactData
  var targetLen = (fullHeaders && fullHeaders.length) || artifactTypes.length;
  while (artifactTypes.length < targetLen) artifactTypes.push('');
  while (tiers.length < targetLen) tiers.push('');
  while (rarities.length < targetLen) rarities.push('');

  Logger.log('artifactTypes count: %s  tiers: %s  rarities: %s', artifactTypes.length, tiers.length, rarities.length);
  Logger.log('fullHeaders length: %s', fullHeaders.length);
  Logger.log('data rows count: %s', rows.length);

  // Build shipFilters
  var paramSheet = _getsheetbyname(CFG.paramsSheet);
  var paramData = paramSheet.getDataRange().getValues();
  var paramHeaders = paramData[0];
  var shipTypeIndex = paramHeaders.indexOf(CFG.paramsCols.shipType);
  var shipLevelIndex = paramHeaders.indexOf(CFG.paramsCols.level);
  var shipFilters = [];
  for (var i = 1; i < paramData.length; i++) shipFilters.push([paramData[i][shipTypeIndex], paramData[i][shipLevelIndex]]);

  // Filter rows
  var filteredRows = [];
  for (var r = 0; r < rows.length; r++) {
    var row = rows[r];
    for (var f = 0; f < shipFilters.length; f++) {
      if (row[0] === shipFilters[f][0] && row[2] === shipFilters[f][1]) { filteredRows.push(row); break; }
    }
  }
  Logger.log('filteredRows count: %s', filteredRows.length);

  // Check column counts
  var maxCols = 0; var minCols = 9999; var sampleIdx = Math.min(10, filteredRows.length);
  for (var j = 0; j < filteredRows.length; j++) {
    var ln = filteredRows[j].length;
    if (ln > maxCols) maxCols = ln;
    if (ln < minCols) minCols = ln;
    if (j < sampleIdx) Logger.log('sample row %s length: %s', j, ln);
  }
  Logger.log('filteredRows minCols=%s maxCols=%s', minCols === 9999 ? 0 : minCols, maxCols);

  // OutputRows dimensions
  var outputRows = [artifactTypes, tiers, rarities, fullHeaders].concat(filteredRows);
  Logger.log('outputRows count: %s  firstRowCols: %s', outputRows.length, outputRows[0] ? outputRows[0].length : 0);
}

/**
 * Show sample of indexed ships and their parameter mappings.
 */
function DIAG_SAMPLE() {
  var built = _buildMissionIndex();
  var keysSt = Object.keys(built.index);
  Logger.log('Ship keys: %s', JSON.stringify(keysSt.slice(0,10)));
  
  var param = _buildParamLevelMap();
  var some = [];
  var count = 0;
  for (var k in param) {
    if (param.hasOwnProperty(k)) {
      some.push(k + ' -> ' + param[k]);
      if (++count >= 10) break;
    }
  }
  Logger.log('Param pairs (first 10): %s', JSON.stringify(some));
}

/**
 * Compare parameter pairs from Ship_Parameters with the data index from AllArtifactData.
 * Logs:
 *  - Pairs missing entirely in the index (ship or duration mismatch)
 *  - Pairs present but missing the requested StarsHelper level
 * Relies on existing helpers: _buildMissionIndex(), _buildParamLevelMap()
 */
function DIAG_PARAM_INDEX_MISMATCHES() {
  var built = _buildMissionIndex();              // { index, header, all, cols }
  var index = built.index;                       // index[ship][duration][level] -> array of rowIdx
  var params = _buildParamLevelMap();            // key: 'SHIP␞DURATION' -> level (StarsHelper)

  var missingPairs = [];     // pairs not in index (unknown ship or duration)
  var missingLevels = [];    // pair exists, but StarsHelper level bucket is absent
  var ok = 0;

  for (var key in params) {
    if (!params.hasOwnProperty(key)) continue;
    var parts = key.split('␞');
    var st = parts[0], du = parts[1];
    var lv = String(params[key]);

    var shipNode = index[st];
    if (!shipNode) {
      missingPairs.push(st + ' | ' + du + '  (param=' + lv + ')  -- unknown ship');
      continue;
    }
    var durNode = shipNode[du];
    if (!durNode) {
      missingPairs.push(st + ' | ' + du + '  (param=' + lv + ')  -- unknown duration');
      continue;
    }
    if (!durNode.hasOwnProperty(lv)) {
      var levelsPresent = Object.keys(durNode)
        .map(function(s){ return Number(s); })
        .sort(function(a,b){ return a-b; });
      missingLevels.push(st + ' | ' + du + '  (param=' + lv + ', index levels=' + JSON.stringify(levelsPresent) + ')');
      continue;
    }
    ok++;
  }

  Logger.log('PARAM→INDEX coverage: OK=%s  missingPairs=%s  missingLevels=%s', ok, missingPairs.length, missingLevels.length);

  if (missingPairs.length) {
    Logger.log('Pairs missing in index (ship or duration mismatch):\n%s', JSON.stringify(missingPairs, null, 2));
  }
  if (missingLevels.length) {
    Logger.log('Pairs present but missing requested level bucket:\n%s', JSON.stringify(missingLevels, null, 2));
  }
}

//TODO: check if this works with current _transformALLArtifactData usage
function DIAG_WHAT_SHIPS_DO_I_HAVE(prefix) {
  var built = _buildMissionIndex();
  var keys = Object.keys(built.index).sort();
  var p = String(prefix || '').toUpperCase();
  var out = [];
  for (var i = 0; i < keys.length; i++) {
    if (!p || keys[i].indexOf(p) !== -1) out.push(keys[i]);
  }
  Logger.log('Known shipType keys%s: %s', p ? ' (filter=' + p + ')' : '', JSON.stringify(out));
}

/**
 * Check parameters sheet for values that need aliases added.
 * Reports any ship types or duration types that aren't covered by the aliases sheet.
 */
function DIAG_MISSING_ALIASES_IN_PARAMS() {
  var read = _readSheet(CFG.paramsSheet);
  var header = read.header, rows = read.rows;
  
  // Get column indices using consistent CFG names
  var cSt = header[String(CFG.paramsCols.shipType).toLowerCase()];
  var cDu = header[String(CFG.paramsCols.shipDurationType).toLowerCase()];
  if (cSt == null || cDu == null) {
    throw new Error(
      'Params sheet missing columns: ' +
      CFG.paramsCols.shipType + ' or ' + CFG.paramsCols.shipDurationType
    );
  }

  var aliases = _buildAliasesFromSheet();
  var missing = { shipType: {}, shipDurationType: {} };

  for (var r = 0; r < rows.length; r++) {
    var shipRaw = rows[r][cSt], durRaw = rows[r][cDu];
    var st = _normalizeWithAliases('shipType', shipRaw, aliases);
    var du = _normalizeWithAliases('shipDurationType', durRaw, aliases);

    // Check both raw value and upper_snake version
    var hasShip = aliases.shipType && 
      (aliases.shipType[shipRaw] || aliases.shipType[_toUpperSnake(shipRaw)]);
    var hasDur = aliases.shipDurationType && 
      (aliases.shipDurationType[durRaw] || aliases.shipDurationType[_toUpperSnake(durRaw)]);

    if (!st || !hasShip) missing.shipType[String(shipRaw)] = true;
    if (!du || !hasDur) missing.shipDurationType[String(durRaw)] = true;
  }

  var missShips = Object.keys(missing.shipType);
  var missDurs = Object.keys(missing.shipDurationType);
  
  if (!missShips.length && !missDurs.length) {
    Logger.log('All ' + CFG.paramsSheet + ' values are covered by ' + CFG.aliasesSheet + '.');
  } else {
    if (missShips.length) {
      Logger.log('Ship aliases missing for: %s', JSON.stringify(missShips));
    }
    if (missDurs.length) {
      Logger.log('Duration aliases missing for: %s', JSON.stringify(missDurs));
    }
  }
}


 /* =========================
   MENU & TRIGGERS
   ========================= */

function onOpen() {
  SpreadsheetApp.getUi().createMenu('Missions')
    .addItem('Write Results (by Param Level)', 'WRITE_RESULTS_SHEET')
    .addItem('Write Results - Keys Only (4 cols)', 'WRITE_RESULTS_KEYS_ONLY')
    .addSeparator()
    .addItem('Bootstrap Aliases', 'BOOTSTRAP_ALIASES')
    .addToUi();
}

function CREATE_ONCHANGE_TRIGGER_FOR_RESULTS() {
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === 'WRITE_RESULTS_SHEET') {
      ScriptApp.deleteTrigger(triggers[i]);
    }
  }
  ScriptApp.newTrigger('WRITE_RESULTS_SHEET')
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onChange()
    .create();
}

function RUN_A_TEST(){
CLEAR_CACHE();
WRITE_RESULTS_SHEET();
  }